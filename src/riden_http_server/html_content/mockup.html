<html>
  <head>
    <title>Riden Multi-Purpose WiFi Dongle</title>
    <style>
      body {
        font-family: sans-serif;
        width: 50%;
        min-width: 720px;
        margin: 10px auto 0 auto;
        color: #383428;
      }
      div {
        margin-bottom: 6px;
      }
      div.header {
        margin-bottom: 10px;
      }
      a#configure {
        float: right;
      }
      div.box {
        background-color: #e4e4e2;
        margin-top: 10px;
        padding: 4px;
      }
      div.danger {
        background-color: #ed2939;
      }
      .danger {
        color: white;
      }
      .danger a,
      .danger a:hover,
      .danger a:active,
      .danger a:visited {
        color: white;
      }
      .box table {
        width: 100%;
      }
      .box h2 {
        text-align: center;
        margin: 0 0 8px 0;
      }
      .box td,
      th {
        text-align: left;
      }
      table.info th {
        text-align: right;
        padding-right: 10px;
        width: 50%;
      }
      table.info td {
        text-align: left;
        padding-left: 10px;
        width: 50%;
      }
      table.clients th {
        text-align: left;
      }
      table.clients td {
        text-align: left;
      }
      table.clients form {
        display: inline;
      }
      .bigtext {
        font-size: 3em;
        font-weight: bold;
        font-family: "Noto Sans Mono", monospace;
        text-align: right !important;
        white-space: nowrap;
        width: 8ch;
      }
      .smalltext {
        font-size: 1em;
        text-align: right !important;
        white-space: nowrap;
      }
      span.smalltext {
        font-weight: bold;
        font-family: "Noto Sans Mono", monospace;
        width: 7ch;
      }
      table.control {
        border-collapse: collapse;
        width: 100%;
      }
      table.control td,
      table.control th {
        padding-left: 10px;
        padding-right: 10px;
      }
      table.control th {
        text-align: center;
      }
      table.control th:nth-child(1),
      table.control td:nth-child(1) {
        text-align: right;
        white-space: nowrap;
      }
      table.control td:nth-child(2) {
        text-align: center;
        white-space: nowrap;
      }
      .onoff {
        text-align: center !important;
      }      
      .onoff button {
        font-size: 1.5em;
      }
      .onoff button.is_on {
        background-color: #0f0 !important;
        color: black !important;
      }
      .onoff button.is_on:hover {
        background-color: rgb(135, 255, 135) !important;
      }      
      .control button {
        margin: 0px 0px 0px 0px;
        color: white;
        background-color: #666;
        padding: 4px 12px;
        border-radius: 4px;
        border: 1px solid #888;
        width: 100%;
        cursor: pointer;
      }
      .control button.active {
        background-color: rgb(212, 212, 212) !important;
        color: black !important;
      }
      .control button:hover {
        background-color: rgb(200, 200, 200) !important;
      }
      .control input[type="number"] {
        font-family: "Noto Sans Mono", monospace;
        font-size: 1.2em;
        text-align: right;
      }
      td.timescale {
        vertical-align: top;
        padding-top: 20px;
      }
      .timescale button {
        margin-top: 10px;
      }
      svg {
        background-color: rgb(233, 233, 233);
      }
    </style>
  </head>
  <body>
    <a id="home" href="/">Home</a>&nbsp;
    <a id="control" href="/control/">Control</a>
    <a id="configure" href="/config/">Configure</a>
<div class="box">
  <a style="float: right" href="/psu/">Details</a>
  <h2>Power Supply Control</h2>
  <div>
    <table class="control">
      <tbody>
        <colgroup>
          <col width="20%" />
          <col width="1%" />
          <col width="1%" />
          <col width="20%" />
        </colgroup>
        <tr>
          <th>Set</th>
          <th></th>
          <th>Output</th>
          <th></th>
        </tr>
        <tr>
          <td>
            <input
              type="number"
              id="set_v"
              size="6"
              value=""
              min="0"
              max="60"
              step="0.01"
            />
          </td>
          <td><button id="setv" onclick="setv()">V-Set &gt;</button></td>
          <td><pre class="bigtext" id="out_v"> -.-- V</pre></td>
          <td>
            <img
              id="cv"
              src="data:image/png;base64,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"
              style="visibility: hidden"
            />
          </td>
        </tr>
        <tr>
          <td>
            <input
              type="number"
              id="set_c"
              size="6"
              value=""
              min="0"
              max="30"
              step="0.01"
            />
          </td>
          <td><button id="seti" onclick="seti()">I-Set &gt;</button></td>
          <td><pre class="bigtext" id="out_i"> -.-- A</pre></td>
          <td>
            <img
              id="cc"
              src="data:image/png;base64,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"
              style="visibility: hidden"
            />
          </td>
        </tr>
        <tr>
          <td colspan="2">
            <table width="100%" class="smalltext">
              <tr>
                <td style="text-align: right; vertical-align: top">
                  <pre>Ah:<span id='ah'>   0.000</span> Ah<br>Wh:<span id='wh'>   0.000</span> Wh</pre>
                </td>
                <td width="1%" style="text-align: right">
                  <pre>ext:<span id='ext_t_c'>-100.0</span>&deg;C<br>int:<span id='int_t_c'>   0.0</span>&deg;C<br>batt:<span id='batt_v'>  0.00</span> V</pre>
                </td>
              </tr>
            </table>
          </td>
          <td class="onoff">
            <button id="toggle" onclick="toggle()">ON/OFF</button>
          </td>
          <td>
            <img
              id="batt"
              src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAAhCAYAAABEM4KbAAAEDmlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPpu5syskzoPUpqaSDv41lLRsUtGE2uj+ZbNt3CyTbLRBkMns3Z1pJjPj/KRpKT4UQRDBqOCT4P9bwSchaqvtiy2itFCiBIMo+ND6R6HSFwnruTOzu5O4a73L3PnmnO9+595z7t4LkLgsW5beJQIsGq4t5dPis8fmxMQ6dMF90A190C0rjpUqlSYBG+PCv9rt7yDG3tf2t/f/Z+uuUEcBiN2F2Kw4yiLiZQD+FcWyXYAEQfvICddi+AnEO2ycIOISw7UAVxieD/Cyz5mRMohfRSwoqoz+xNuIB+cj9loEB3Pw2448NaitKSLLRck2q5pOI9O9g/t/tkXda8Tbg0+PszB9FN8DuPaXKnKW4YcQn1Xk3HSIry5ps8UQ/2W5aQnxIwBdu7yFcgrxPsRjVXu8HOh0qao30cArp9SZZxDfg3h1wTzKxu5E/LUxX5wKdX5SnAzmDx4A4OIqLbB69yMesE1pKojLjVdoNsfyiPi45hZmAn3uLWdpOtfQOaVmikEs7ovj8hFWpz7EV6mel0L9Xy23FMYlPYZenAx0yDB1/PX6dledmQjikjkXCxqMJS9WtfFCyH9XtSekEF+2dH+P4tzITduTygGfv58a5VCTH5PtXD7EFZiNyUDBhHnsFTBgE0SQIA9pfFtgo6cKGuhooeilaKH41eDs38Ip+f4At1Rq/sjr6NEwQqb/I/DQqsLvaFUjvAx+eWirddAJZnAj1DFJL0mSg/gcIpPkMBkhoyCSJ8lTZIxk0TpKDjXHliJzZPO50dR5ASNSnzeLvIvod0HG/mdkmOC0z8VKnzcQ2M/Yz2vKldduXjp9bleLu0ZWn7vWc+l0JGcaai10yNrUnXLP/8Jf59ewX+c3Wgz+B34Df+vbVrc16zTMVgp9um9bxEfzPU5kPqUtVWxhs6OiWTVW+gIfywB9uXi7CGcGW/zk98k/kmvJ95IfJn/j3uQ+4c5zn3Kfcd+AyF3gLnJfcl9xH3OfR2rUee80a+6vo7EK5mmXUdyfQlrYLTwoZIU9wsPCZEtP6BWGhAlhL3p2N6sTjRdduwbHsG9kq32sgBepc+xurLPW4T9URpYGJ3ym4+8zA05u44QjST8ZIoVtu3qE7fWmdn5LPdqvgcZz8Ww8BWJ8X3w0PhQ/wnCDGd+LvlHs8dRy6bLLDuKMaZ20tZrqisPJ5ONiCq8yKhYM5cCgKOu66Lsc0aYOtZdo5QCwezI4wm9J/v0X23mlZXOfBjj8Jzv3WrY5D+CsA9D7aMs2gGfjve8ArD6mePZSeCfEYt8CONWDw8FXTxrPqx/r9Vt4biXeANh8vV7/+/16ffMD1N8AuKD/A/8leAvFY9bLAAAAOGVYSWZNTQAqAAAACAABh2kABAAAAAEAAAAaAAAAAAACoAIABAAAAAEAAAApoAMABAAAAAEAAAAhAAAAANOY7aQAAAEySURBVFgJ7ZhBCsIwEEV/ooJYdCMU69KNK09ij1vv4cojKHQlBUWwGhOlYRRpaRJswMymM20yef0zbWkYiI3BxQqMnOnG3UmGI0oNoh0FGGWDbqi+rHpJbxr0CekbYMVcgTJfASvQU3oFj9CrYi+PU3D0XZId1hedLtkMtW/rOINUgBTsM7YB5TaTfzWXzTAQyMxYaXmbgKnKTWPp9aF8FRmXu205246noGYS0gw/8I2VpGx1ZTctM83/P0q6UIsq9+n/j5KhJ2XtnTzdoSddKRl60pWSoSddKRl60pWSoSdtlFTq1fWizP1mNmpbfRZtFn67g4aAFyiRyJ8dH22Rlshxe22hjcDEUu5kHDJ/djMU4BZ3nCGY3lXzCZQCqgprSBXM41hMhPK6tUJS7fNcsz0A2HpaTvrlARMAAAAASUVORK5CYII="
              style="display: none"
            />
            <img
              id="nobatt"
              src="data:image/png;base64,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"
              style="display: inline"
            />
            <img
              id="ocp"
              src="data:image/png;base64,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"
              style="display: none"
            />
            <img
              id="ovp"
              src="data:image/png;base64,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"
              style="display: none"
            />
          </td>
        </tr>
      </tbody>
    </table>
  </div>
</div>
<div class="box">
  <table class="control">
    <colgroup>
      <col width="20%" />
      <col width="1%" />
      <col width="1%" />
      <col width="20%" />
    </colgroup>
    <tr>
      <td></td>
      <td><div id="graph" align="center"></div></td>
      <td class="timescale">
        <button id="time0" onclick="timescale(0);" class="active">All</button><br />
        <button id="time1" onclick="timescale(1);">1h</button><br />
        <button id="time2" onclick="timescale(2);">5m</button><br />
        <button id="time3" onclick="timescale(3);">30s</button><br />
        <button id="time4" onclick="timescale(4);">Clear</button><br />
      </td>
      <td></td>
    </tr>
  </table>
</div>
<script type="module">
  import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

  // time series chart from https://observablehq.com/@geofduf/simple-dashboard-line-charts, but adapted in multiple locations
  class TimeSeriesChart {
    constructor({
      data,
      width = 500,
      height = 196,
      title,
      yMin,
      yMax,
      format = ".4~s",
      legendValues = [],
      rightFooter,
      selectionHandler,
      series = [],
    } = {}) {
      this._data = data;
      this._sourcedata = data;
      this._width = width;
      this._height = height;
      this._title = title;
      this._yMin = yMin;
      this._yMax = yMax;
      this._format = format;
      this._legendValues = legendValues;
      this._rightFooter = rightFooter;
      this._selectionHandler = selectionHandler;
      this._series = series;
      this._xStart = 0;
      this._xEnd = 0;
    }

    get svg() {
      if (this._svg === undefined) {
        this._render();
      }
      return this._svg.node();
    }

    get data() {
      return this._data;
    }

    set data(data) {
      this._sourcedata = data;
      this.refreshData();
    }

    appendTo(selector) {
      d3.select(selector).append(() => this.svg);
    }

    appendData(newdata) {
      this._sourcedata.push(newdata);
      if (
        typeof this._xStart !== "number" &&
        typeof this._xEnd !== "number"
      )
        return;
      this.refreshData();
    }

    clearData() {
      this._sourcedata = [];
      this._xStart = 0;
      this._xEnd = 0;
      this.refreshData();
    }

    setXLimits(startOffset, endOffset) {
      this._xStart = startOffset;
      this._xEnd = endOffset;
      this.refreshData();
    }

    refreshData() {
      let newdata = this._sourcedata;
      if (this._xStart) {
        let xStart = this._xStart;
        if (typeof this._xStart === "number") {
          xStart = new Date(Date.now() - this._xStart);
        }
        newdata = newdata.filter((d) => d.date >= xStart);
      }
      if (this._xEnd) {
        let xEnd = this._xEnd;
        if (typeof this._xEnd === "number") {
          xEnd = new Date(Date.now() - this._xEnd);
        }
        newdata = newdata.filter((d) => d.date <= xEnd);
      }
      this._data = newdata;

      if (this._svg === undefined) {
        return;
      }

      const transitionDuration = 0; // set to 400 for example for smooth scrolling, but that gives flickering

      const [yDomain, legendEntries] = this._prepare(this._data);

      this._xScale.domain(d3.extent(this._data, (d) => d.date));
      this._yScale.domain(yDomain).nice();

      this._svg
        .select(".x-axis")
        .transition()
        .duration(transitionDuration)
        .ease(d3.easeExp)
        .call(this._xAxis(this._xScale));

      this._svg
        .select(".y-axis")
        .transition()
        .duration(transitionDuration)
        .ease(d3.easeExp)
        .call(this._yAxis(this._yScale));

      const pathFn = this._pathFn;

      this._svg.selectAll(".path").each(function () {
        d3.select(this)
          .transition()
          .duration(transitionDuration / 2)
          .ease(d3.easeLinear)
          .attr("opacity", 0.0)
          .on("end", function () {
            d3.select(this)
              .attr("d", pathFn[this.dataset.fn](newdata))
              .transition()
              .duration(transitionDuration / 2)
              .ease(d3.easeExp)
              .attr("opacity", 1.0);
          });
      });

      this._svg
        .selectAll(".legend-text")
        .data(legendEntries)
        .text((d) => d.text);
    }

    _render() {
      // Environment, formatters, helpers
      const margin = { top: 24, right: 0, bottom: 18, left: 50 };
      const legendFontSize = 11;
      const formatAsDate = d3.timeFormat("%-m/%-d");
      const formatAsTime = d3.timeFormat("%-H:%M:%S");
      const formatAsDateTime = d3.timeFormat("%Y-%m-%d %H:%M:%S");
      const xTickFormatter = (d) =>
        d.getHours() === 0 && d.getMinutes() === 0
          ? formatAsDate(d)
          : formatAsTime(d);
      const yTickFormatter =
        typeof this._format === "function"
          ? this._format("axis")
          : d3.format(this._format);
      const yValueFormatter =
        typeof this._format === "function"
          ? this._format("value")
          : d3.format(this._format);

      const boundaries = {
        left: margin.left,
        right: this._width - margin.right,
        top: margin.top,
        bottom: this._height - margin.bottom,
      };

      const axisStyler = (g) => {
        g.selectAll("line")
          .attr("stroke", "lightgrey")
          .attr("stroke-opacity", 0.7)
          .attr("shape-rendering", "geometricPrecision");
        if (g.node().classList.contains("y-axis")) {
          g.select(".domain").attr("opacity", 0.0);
        } else {
          g.select(".domain").attr("stroke", "grey");
        }
      };

      // Calculate y axis domain and prepare legendentries if needed
      const [yDomain, legendEntries] = this._prepare(this._data);

      const footerRows =
        legendEntries.length === 0 && this._rightFooter !== undefined
          ? 1
          : legendEntries.length;

      // Start building the svg
      const svg = d3
        .create("svg")
        .attr("width", this._width)
        .attr("height", this._height + footerRows * (legendFontSize + 3));

      const xScale = d3
        .scaleTime()
        .domain(d3.extent(this._data, (d) => d.date))
        .range([boundaries.left, boundaries.right]);

      const xAxis = (scale) => {
        return (g) =>
          g
            .attr("class", "x-axis")
            .attr("transform", `translate(0, ${boundaries.bottom})`)
            .call(
              d3
                .axisBottom(scale)
                .ticks(6)
                .tickPadding(8)
                .tickSizeInner(boundaries.top - boundaries.bottom)
                .tickSizeOuter(0)
                .tickFormat(xTickFormatter)
            )
            .call(axisStyler);
      };

      const yScale = d3
        .scaleLinear()
        .domain(yDomain)
        .range([boundaries.bottom, boundaries.top])
        .nice();

      const yAxis = (scale) => {
        return (g) =>
          g
            .attr("class", "y-axis")
            .attr("transform", `translate(${boundaries.left}, 0)`)
            .call(
              d3
                .axisLeft(scale)
                .ticks(5)
                .tickPadding(8)
                .tickSizeInner(boundaries.left - boundaries.right)
                .tickSizeOuter(0)
                .tickFormat(yTickFormatter)
            )
            .call(axisStyler);
      };

      svg.append("g").call(yAxis(yScale));
      svg.append("g").call(xAxis(xScale));

      // A unique identifier is required for the clip-path element (no success finding
      // an alternative with <basic-shape> and <geometry-box> under Chrome).
      // -> Basic helper to prevent things to break if multiple components
      // are generated on the same page. In observable, consider using DOM.uid() instead.
      if (!window.hasOwnProperty("TimeSeriesChartCounter")) {
        window.TimeSeriesChartCounter = 0;
      }
      const clipId = `timeserieschart-clip-${++window.TimeSeriesChartCounter}`;

      svg
        .append("defs")
        .append("clipPath")
        .attr("id", clipId)
        .append("rect")
        .attr("x", boundaries.left)
        .attr("y", boundaries.top - 1)
        .attr("width", boundaries.right - boundaries.left)
        .attr("height", boundaries.bottom - boundaries.top + 2);

      let pathCnt = 0;
      const pathFn = {};
      const tooltipMetrics = [];

      for (const [i, s] of this._series.entries()) {
        const yPrepared =
          s.hasOwnProperty("negativeY") && s.negativeY
            ? (d) => yScale(-d[s.metric])
            : (d) => yScale(d[s.metric]);

        if (s.hasOwnProperty("lineColor")) {
          pathCnt++;

          const line = d3
            .line()
            .defined((d) => d[s.metric] !== null)
            .x((d) => xScale(d.date))
            .y(yPrepared);

          svg
            .append("path")
            .datum(this._data)
            .attr("data-fn", `path-${pathCnt}`)
            .attr("class", "path")
            .attr("clip-path", `url(#${clipId})`)
            .attr("stroke", s.lineColor)
            .attr("fill", "none")
            .attr("stroke-width", 1.0)
            .attr("opacity", 1.0)
            .attr("d", line)
            .style("-webkit-clip-path", `url(#${clipId})`);

          pathFn[`path-${pathCnt}`] = line;
        }

        if (s.hasOwnProperty("fillColor")) {
          let baseline;
          let defined;

          pathCnt++;

          if (s.hasOwnProperty("fillToMetric") && s.fillToMetric) {
            baseline =
              s.hasOwnProperty("negativeY") && s.negativeY
                ? (d) => yScale(-d[s.fillToMetric])
                : (d) => yScale(d[s.fillToMetric]);
            defined = (d) =>
              d[s.metric] !== null && d[s.metric] >= d[s.fillToMetric];
          } else if (s.hasOwnProperty("fillToZero") && s.fillToZero) {
            baseline = (d) => yScale(0);
            defined = (d) => d[s.metric] !== null && d[s.metric] >= 0;
          } else {
            baseline =
              s.hasOwnProperty("negativeY") && s.negativeY
                ? (d) => yScale(yScale.domain()[1])
                : (d) => yScale(yScale.domain()[0]);
            defined = (d) => d[s.metric] !== null;
          }

          const [y0, y1] =
            s.hasOwnProperty("negativeY") && s.negativeY
              ? [yPrepared, baseline]
              : [baseline, yPrepared];

          const area = d3
            .area()
            .defined(defined)
            .x((d) => xScale(d.date))
            .y0(y0)
            .y1(y1);

          svg
            .append("path")
            .datum(this._data)
            .attr("data-fn", `path-${pathCnt}`)
            .attr("class", "path")
            .attr("clip-path", `url(#${clipId})`)
            .attr("stroke", "none")
            .attr("fill", s.fillColor)
            .attr("opacity", 1.0)
            .attr("d", area)
            .style("-webkit-clip-path", `url(#${clipId})`);

          pathFn[`path-${pathCnt}`] = area;
        }

        if (s.hasOwnProperty("tooltip") && s.tooltip) {
          tooltipMetrics.push({ metric: s.metric, label: s.label });
        }
      }

      if (
        this._selectionHandler !== undefined ||
        tooltipMetrics.length > 0
      ) {
        const context = d3.create("svg:g");
        let brush;

        if (this._selectionHandler !== undefined) {
          brush = d3
            .brushX()
            .extent([
              [boundaries.left, boundaries.top],
              [boundaries.right, boundaries.bottom],
            ])
            .on("start end", ({ target, type, selection }) => {
              svg.selectAll(".interactive").style("display", "none");
              if (type === "end" && selection !== null) {
                this._selectionHandler(
                  this,
                  ...selection.map(xScale.invert)
                );
                svg.select(".brush").call(target.move, null);
              }
            });

          context.attr("class", "brush");
          context.call(brush);
          svg.attr("cursor", "crosshair");
        } else {
          context
            .append("rect")
            .attr("x", boundaries.left)
            .attr("y", boundaries.top)
            .attr("width", boundaries.right - boundaries.left)
            .attr("height", boundaries.bottom - boundaries.top)
            .attr("fill", "none")
            .attr("pointer-events", "all");
        }

        if (tooltipMetrics.length > 0) {
          const tooltipHeight =
            20 + tooltipMetrics.length * (legendFontSize + 3);

          const tooltip = d3
            .create("svg:g")
            .attr("class", "interactive")
            .attr("font-family", "monospace")
            .attr("font-size", legendFontSize + "px")
            .attr("font-weight", "normal")
            .attr("fill", "black")
            .attr("stroke", "none")
            .attr("opacity", 0.8)
            .style("display", "none");

          tooltip
            .append("rect")
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", 140)
            .attr("height", tooltipHeight)
            .attr("fill", "white")
            .attr("stroke", "black")
            .attr("stroke-opacity", 0.5)
            .attr("shape-rendering", "crispEdges");

          tooltip
            .append("text")
            .attr("class", "tooltip-x-value")
            .attr("x", 70)
            .attr("y", 12)
            .attr("text-anchor", "middle");

          let offset = 25;

          for (const v of tooltipMetrics) {
            tooltip
              .append("text")
              .attr("x", 10)
              .attr("y", offset)
              .attr("text-anchor", "start")
              .text(v.label);

            tooltip
              .append("text")
              .attr("class", "tooltip-y-value")
              .attr("x", 130)
              .attr("y", offset)
              .attr("text-anchor", "end");

            offset += legendFontSize + 3;
          }

          const focus = svg
            .append("line")
            .attr("class", "interactive")
            .attr("x1", 0)
            .attr("x2", 0)
            .attr("y1", boundaries.top)
            .attr("y2", boundaries.bottom)
            .attr("stroke", "red")
            .attr("opacity", 0.5)
            .style("display", "none");

          const bisect = d3.bisector((d) => d.date).left;
          const flipCoordinates = [
            boundaries.right - 155,
            boundaries.bottom - tooltipHeight - 10,
          ];

          const mouseMoved = ({ offsetX: x, offsetY: y }) => {
            if (
              x < boundaries.left ||
              x > boundaries.right ||
              y < boundaries.top ||
              y > boundaries.bottom
            ) {
              return;
            }

            if (focus.style("display") !== "block") {
              focus.style("display", "block");
            }

            if (tooltip.style("display") !== "block") {
              tooltip.style("display", "block");
            }

            const date = xScale.invert(x);
            const index = bisect(this._data, date, 1);
            const row =
              date - this._data[index - 1].date >
              this._data[index].date - date
                ? this._data[index]
                : this._data[index - 1];
            const focusX = xScale(row.date);
            const tooltipX =
              focusX < flipCoordinates[0] ? focusX + 15 : focusX - 155;
            const tooltipY =
              y < flipCoordinates[1] ? y + 10 : y - tooltipHeight - 10;

            focus.attr("transform", `translate(${focusX}, 0)`);
            tooltip.attr(
              "transform",
              `translate(${tooltipX}, ${tooltipY})`
            );
            tooltip
              .select(".tooltip-x-value")
              .text(formatAsDateTime(row.date));
            tooltip
              .selectAll(".tooltip-y-value")
              .data(tooltipMetrics)
              .text((d) =>
                row[d.metric] !== null
                  ? yValueFormatter(row[d.metric])
                  : "n/a"
              );
          };

          if (brush !== undefined) {
            brush.on("brush", ({ sourceEvent }) => {
              if (
                sourceEvent !== undefined &&
                sourceEvent.type === "mousemove"
              ) {
                mouseMoved(sourceEvent);
              }
            });
          }

          context
            .on("touchend mouseleave", () => {
              svg.selectAll(".interactive").style("display", "none");
            })
            .on("touchmove mousemove", mouseMoved);

          svg.append((d) => context.node());
          svg.append((d) => tooltip.node());
        } else {
          svg.append((d) => context.node());
        }
      }

      if (footerRows > 0) {
        const footer = svg
          .append("g")
          .attr("transform", `translate(0, ${this._height})`)
          .attr("font-family", "monospace")
          .attr("font-size", legendFontSize + "px")
          .attr("font-weight", "normal");

        let offset = (legendFontSize + 3) / 2;

        if (this._rightFooter !== undefined) {
          footer
            .append("text")
            .attr("x", boundaries.right - 5)
            .attr("y", offset)
            .attr("text-anchor", "end")
            .attr("dominant-baseline", "middle")
            .style("white-space", "pre")
            .text(this._rightFooter);
        }

        for (const v of legendEntries) {
          footer
            .append("rect")
            .attr("width", 12)
            .attr("height", 4)
            .attr("x", margin.left / 2 + 4)
            .attr("y", offset - 2)
            .attr("rx", 2)
            .attr("ry", 2)
            .attr("fill", v.color);

          footer
            .append("text")
            .attr("class", "legend-text")
            .attr("x", margin.left / 2 + 20)
            .attr("y", offset)
            .attr("dominant-baseline", "middle")
            .style("white-space", "pre")
            .text(v.text);

          offset += legendFontSize + 3;
        }
      }

      if (this._title !== undefined) {
        svg
          .append("text")
          .attr("x", this._width / 2)
          .attr("y", margin.top / 2)
          .attr("font-family", "sans-serif")
          .attr("font-size", "12px")
          .attr("font-weight", "bold")
          .attr("text-anchor", "middle")
          .text(this._title);
      }

      this._xScale = xScale;
      this._yScale = yScale;
      this._xAxis = xAxis;
      this._yAxis = yAxis;
      this._pathFn = pathFn;
      this._svg = svg;
    }

    _prepare(data) {
      const yDomain = [
        this._yMin !== undefined ? this._yMin : Infinity,
        this._yMax !== undefined ? this._yMax : -Infinity,
      ];

      const yValueFormatter =
        typeof this._format === "function"
          ? this._format("value")
          : d3.format(this._format);
      const formatter = (v) =>
        v !== null && v !== undefined
          ? yValueFormatter(v).padEnd(9, " ")
          : "n/a      ";

      const legendValues = [
        ...new Set(
          this._legendValues.filter((v) =>
            ["Min", "Max", "Avg", "Last"].includes(v)
          )
        ),
      ];

      const legendEntries = [];

      for (const s of this._series) {
        const aggs = {};

        if (s.hasOwnProperty("legend") && s.legend) {
          if (legendValues.includes("Min")) {
            aggs.min = d3.min(data, (d) => d[s.metric]);
          }

          if (legendValues.includes("Max")) {
            aggs.max = d3.max(data, (d) => d[s.metric]);
          }

          if (legendValues.includes("Avg")) {
            aggs.avg = d3.mean(data, (d) => d[s.metric]);
          }

          if (legendValues.includes("Last")) {
            if (data.length === 0) {
              aggs.last = null;
            } else {
              aggs.last = data[data.length - 1][s.metric];
            }
          }

          legendEntries.push({
            color: s.lineColor ?? s.fillColor ?? "white",
            text:
              s.label.padEnd(15, " ") +
              legendValues
                .map((v) => `${v}: ${formatter(aggs[v.toLowerCase()])}`)
                .join(""),
          });
        }

        // Calculate the y scale domain if needed.
        // Will use existing values when possible.
        if (this._yMin === undefined) {
          if (s.hasOwnProperty("negativeY") && s.negativeY) {
            yDomain[0] = aggs.hasOwnProperty("max")
              ? Math.min(yDomain[0], -aggs.max)
              : Math.min(yDomain[0], -d3.max(data, (d) => d[s.metric]));
          } else {
            yDomain[0] = aggs.hasOwnProperty("min")
              ? Math.min(yDomain[0], aggs.min)
              : Math.min(
                  yDomain[0],
                  d3.min(data, (d) => d[s.metric])
                );
          }
        }

        if (this._yMax === undefined) {
          if (s.hasOwnProperty("negativeY") && s.negativeY) {
            yDomain[1] = aggs.hasOwnProperty("min")
              ? Math.max(yDomain[1], -aggs.min)
              : Math.max(yDomain[1], -d3.min(data, (d) => d[s.metric]));
          } else {
            yDomain[1] = aggs.hasOwnProperty("max")
              ? Math.max(yDomain[1], aggs.max)
              : Math.max(
                  yDomain[1],
                  d3.max(data, (d) => d[s.metric])
                );
          }
        }
      }

      if (yDomain[0] === yDomain[1]) {
        if (this._yMax !== undefined) {
          yDomain[0]--;
        } else {
          yDomain[1]++;
        }
      }

      return [yDomain, legendEntries];
    }
  }

  // *******************************************************
  // *******************************************************
  // *******************************************************
  // *******************************************************

  // called when the user selects an area in the graph
  function selectionHandler(caller, start, end) {
    caller.setXLimits(start, end);
    timescale(-1); // Clear the timescale selection
  }

  // creation and configuration of the chart
  const chart = new TimeSeriesChart({
    data: [],
    width: 600,
    height: 300,
    yMin: 0,
    format: ".2f",
    legendValues: ["Min", "Max", "Avg", "Last"],
    selectionHandler: selectionHandler,
    series: [
      {
        metric: "out_v",
        label: "Voltage (V)",
        lineColor: "#1f77b4",
        legend: true,
        tooltip: true,
      },
      {
        metric: "out_c",
        label: "Current (A)",
        lineColor: "#ff7f0e",
        legend: true,
        tooltip: true,
      },
    ],
  });

  chart.appendTo("#graph");
  self.chart = chart;
</script>
<script>
  // refresh data 
  function set_data(data, full_set = false) {
    if (data === "") {
      return;
    }
    const obj = JSON.parse(data);
    self.out_v.innerHTML = obj.out_v.toFixed(2).padStart(6, " ") + " V";
    self.out_i.innerHTML = obj.out_c.toFixed(2).padStart(6, " ") + " A";
    if (full_set) {
      self.set_v.value = obj.set_v.toFixed(2);
      self.set_c.value = obj.set_c.toFixed(2);
    }
    document
      .getElementById("set_v")
      .setAttribute("max", obj.max_v.toFixed(2));
    document
      .getElementById("set_c")
      .setAttribute("max", obj.max_c.toFixed(2));
    if (obj.out_on) {
      document.getElementById("toggle").classList.add("is_on");
    } else {
      document.getElementById("toggle").classList.remove("is_on");
    }
    if (obj.cvmode) {
      document.getElementById("cv").style.visibility = "visible";
      document.getElementById("cc").style.visibility = "hidden";
    } else {
      document.getElementById("cv").style.visibility = "hidden";
      document.getElementById("cc").style.visibility = "visible";
    }
    if (obj.ext_t_c === null) {
      self.ext_t_c.innerHTML = "  --.-";
    } else {
      self.ext_t_c.innerHTML = obj.ext_t_c.toFixed(1).padStart(6, " ");
    }
    self.int_t_c.innerHTML = obj.int_t_c.toFixed(1).padStart(6, " ");
    self.batt_v.innerHTML = obj.batt_v.toFixed(2).padStart(6, " ");
    self.ah.innerHTML = obj.ah.toFixed(3).padStart(8, " ");
    self.wh.innerHTML = obj.wh.toFixed(3).padStart(8, " ");
    let img = "nobatt";
    if (obj.prot === "OVP") {
      img = "ovp";
    } else if (obj.prot === "OCP") {
      img = "ocp";
    } else if (obj.batt_mode) {
      img = "batt";
    }
    document.getElementById("batt").style.display = "none";
    document.getElementById("nobatt").style.display = "none";
    document.getElementById("ovp").style.display = "none";
    document.getElementById("ocp").style.display = "none";
    document.getElementById(img).style.display = "inline";
    if (self.chart) {
      self.chart.appendData({
        date: new Date(),
        out_v: obj.out_v,
        out_c: obj.out_c,
      });
    }
  }

  // ticker for fetching data from the server
  let tick_done = true; // Flag to prevent multiple ticks
  function tick(full_set = false) {
    if (!tick_done) {
      console.warn("Tick already in progress, skipping this tick. The PSU is too slow.");
      return;
    }
    tick_done = false; // Set flag to indicate tick is in progress
    try {
      fetch("/status")
        .then((response) => {
          if (!response.ok) {
            return "";
          }
          return response.text();
        })
        .then((data) => {
          if (data !== "") {
            set_data(data, full_set);
          } else {
            console.warn("No data received from /status");
          }
          tick_done = true; // Reset flag after processing
        });
    } catch (e) {
      console.error("Error fetching status:", e);
      tick_done = true;
    }
  }

  // Set the voltage
  function setv() {
    const v = self.set_v.value.trim();
    if (v === "") {
      alert("Please enter a voltage");
      return;
    }
    document.body.style.cursor = "wait";
    document.getElementById("setv").style.cursor = "wait";
    try {
      fetch("/set_v", { method: "POST", body: v }).then((response) => {
        document.body.style.cursor = "default";
        document.getElementById("setv").style.cursor = "pointer";
        if (!response.ok) {
          throw new Error("ERR: " + response.statusText);
        }
      });
    } catch (e) {
      console.error("Error setting voltage:", e);
      alert("Error setting voltage: " + e.message);
      document.body.style.cursor = "default";
      document.getElementById("setv").style.cursor = "pointer";
    }
  }

  // Set the current
  function seti() {
    const v = self.set_c.value.trim();
    if (v === "") {
      alert("Please enter a current");
      return;
    }
    document.body.style.cursor = "wait";
    document.getElementById("seti").style.cursor = "wait";
    try {
      fetch("/set_i", { method: "POST", body: v }).then((response) => {
        document.body.style.cursor = "default";
        document.getElementById("seti").style.cursor = "pointer";
        if (!response.ok) {
          throw new Error("ERR: " + response.statusText);
        }
      });
    } catch (e) {
      console.error("Error setting current:", e);
      alert("Error setting current: " + e.message);
      document.body.style.cursor = "default";
      document.getElementById("seti").style.cursor = "pointer";
    }
  }

  // toggle output on/off
  function toggle() {
    document.body.style.cursor = "wait";
    document.getElementById("toggle").style.cursor = "wait";
    try {
      fetch("/toggle_out")
        .then((response) => {
          document.body.style.cursor = "default";
          document.getElementById("toggle").style.cursor = "pointer";
          if (!response.ok) {
            throw new Error("ERR: " + response.statusText);
          }
          return response.text();
        })
        .then((data) => {
          set_data(data, false);
        });
    } catch (e) {
      console.error("Error in toggle:", e);
      alert("Error in toggle: " + e.message);
      document.body.style.cursor = "default";
      document.getElementById("toggle").style.cursor = "pointer";
    }
  }

  // Function to handle timescale button clicks
  // This function updates the active button and sets the chart's x-axis limits
  // It also clears the chart data if the "Clear" button is clicked
  // When called with -1, it clears the buttons (User's selection of an area)
  function timescale(t) {
    const buttons = document.querySelectorAll(".timescale button");
    buttons.forEach((button) => {
      button.classList.remove("active");
    });
    if (t >= 0) {
      if (t < 4) {
        document.getElementById("time" + t).classList.add("active");
      } else {
        document.getElementById("time0").classList.add("active");
      }
    }
    if (t === 0) {
      self.chart.setXLimits(0, 0);
    } else if (t === 1) {
      self.chart.setXLimits(60 * 60 * 1000, 0);
    } else if (t === 2) {
      self.chart.setXLimits(5 * 60 * 1000, 0);
    } else if (t === 3) {
      self.chart.setXLimits(30 * 1000, 0);
    } else if (t === 4){
      self.chart.clearData();
    }
  }

  // Get the initial data and start the tick loop
  window.addEventListener("load", function () {
    tick(true);
    setInterval(tick, 1000);
  });
</script>
  </body>
</html>
