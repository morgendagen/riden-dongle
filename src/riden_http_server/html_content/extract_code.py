# This script reads an HTML file and extracts the content before and after a specific split string.
import re

SOURCE_FILE = "mockup.html"
DEST_FILE = "../http_static.h"


def extract_code(content: str, name: str) -> str:
    # Extracts the content from the HTML file, removes comments, and formats it as a C string.
    content = content.strip()
    # remove all "//" comments in the content
    content = "\n".join(re.split(r'\s//', line)[0].rstrip() for line in content.splitlines())
    # remove all "//" comments at the start of the lines
    content = "\n".join(line for line in content.splitlines() if not line.lstrip().startswith("//"))
    # remove all empty lines
    content = "\n".join(line for line in content.splitlines() if line.strip() != "")
    # escape special characters for C string
    content = content.replace("\r", "")
    content = content.replace("\\", "\\\\")
    content = content.replace("\"", "\\\"")
    # replace newlines with string concatenations for C
    content = content.replace("\n", "\\n\"\n    \"")
    # print the content as a C string
    content = f"    \"{content}\";"
    return content


def insert_code(dest: str, name: str, code: str, prefix: str, postfix: str) -> str:
    # Inserts the code into the destination file, replacing any existing code with the same name.
    prefix2 = f"static const char {name}[] PROGMEM ="
    newcontent = ""

    mode = 0  # search for the prefix
    nextmode = 0  # next mode
    for line in dest.splitlines():
        # everything before and after maintained section is to be kept
        if mode != 2:
            newcontent += line + "\n" 
            
        # search for the prefix
        if mode == 0 and line.strip().startswith(prefix):
            nextmode = 1
        # prefix must be followed by a static const char declaration
        if mode == 1:
            if line.strip().startswith(prefix2):
                nextmode = 2
                newcontent += code + "\n"
            else:
                nextmode = 0
        # search for the postfix
        if mode == 2:
            if line.strip().startswith(postfix):
                newcontent += line + "\n"  # still copy the postfix
                nextmode = 3
        mode = nextmode
    if mode != 3:
        print(f"Error: section {name} was not found in the destination file.")
        exit(1)
    return newcontent


if __name__ == "__main__":
    if not SOURCE_FILE.endswith(".html"):
        print(f"Source file '{SOURCE_FILE}' is not an HTML file.")
        exit(1)
    if not DEST_FILE.endswith(".h"):
        print(f"Destination file '{DEST_FILE}' is not a header file.")
        exit(1)
        
    with open(SOURCE_FILE, "r", encoding="utf-8") as f:
        content = f.read()
        
    with open(DEST_FILE, "r", encoding="utf-8") as f:
        dest = f.read()

    index = content.find('<div class="')
    if index == -1:
        print("<div class=\"... tag not found in the content.")
        exit(1)
    header = content[:index]
    body = content[index:]
    index = body.find("</body>")
    if index == -1:
        print("</body> tag not found in the content.")
        exit(1)
    body = body[:index]

    prefix = f"// DO NOT MODIFY THIS SECTION. IT IS MAINTAINED BY 'extract_code.py', generated from '{SOURCE_FILE}'"
    postfix = "// END OF SECTION GENERATED BY 'extract_code.py'"
    
    header = extract_code(header, "HTML_HEADER")
    body = extract_code(body, "HTML_CONTROL_BODY")
    dest = insert_code(dest, "HTML_HEADER", header, prefix, postfix)
    dest = insert_code(dest, "HTML_CONTROL_BODY", body, prefix, postfix)
    
    with open(DEST_FILE, "w", encoding="utf-8") as f:
        f.write(dest)
        
    print(f"Extracted code from '{SOURCE_FILE}' and inserted it into '{DEST_FILE}'.")
